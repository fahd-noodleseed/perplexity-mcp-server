# `perplexity-mcp-server`: Architectural Standard & Developer Mandate

**Effective Date:** 2025-07-21
**Version:** 3.0

## Preamble

This document constitutes the official mandate governing all development practices, architectural patterns, and operational procedures for the `perplexity-mcp-server`. It adapts the `mcp-ts-template` standard and is the single source of truth for ensuring code quality, consistency, and long-term maintainability. Adherence to these standards is not optional.

---

## I. Core Architectural Principles

The architecture is founded upon a strict separation of concerns to guarantee modularity, testability, and operational clarity. These principles are non-negotiable.

### 1. The Logic Throws, The Handler Catches

This is the immutable cornerstone of the error-handling and control-flow strategy.

- **Core Logic (`logic.ts`):** This layer's sole responsibility is the execution of business logic. It shall be pure and self-contained. If an operational or validation error occurs, it **must** terminate its execution by **throwing a structured `McpError`**. Logic files shall **not** contain `try...catch` blocks for formatting a final response.

- **Handlers (`registration.ts`):** This layer's responsibility is to interface with the MCP server, invoke core logic, and manage the final response lifecycle. It **must wrap every call** to the logic layer in a `try...catch` block. This is the exclusive location where errors are caught, processed by the `ErrorHandler`, and formatted into a definitive `CallToolResult`.

### 2. Structured, Traceable Operations

Every operation must be fully traceable from initiation to completion via structured logging and context propagation.

- **RequestContext:** Any significant operation shall be initiated by creating a `RequestContext` via `requestContextService.createRequestContext()`. This context, containing a unique `requestId`, **must be passed** as an argument through the entire call stack.

- **Logger:** All logging shall be performed through the centralized `logger` singleton. Every log entry **must include the `RequestContext`** to ensure traceability.

---

## II. Tool Development Workflow

This section mandates the workflow for creating and modifying all tools. Deviation is not permitted.

### A. File and Directory Structure

Each tool shall reside in a dedicated directory within `src/mcp-server/tools/`. The structure is fixed:

- **`toolName/`**
  - **`index.ts`**: A barrel file that exports the `register...` function from `registration.ts`. No other logic.
  - **`logic.ts`**: Contains the tool's core business logic. Defines and exports the Zod input/output schemas, all inferred TypeScript types, and the primary logic function.
  - **`registration.ts`**: Registers the tool with the MCP server. Implements the "Handler" role.

### B. The Canonical Pattern for All Tools

The following pattern, based on the `mcp-ts-template`, is the authoritative implementation and shall be used as the template for all new and refactored tools.

#### **Step 1: Define Schema and Logic (`logic.ts`)**

The `logic.ts` file defines the tool's contract (schemas) and its pure function.

```typescript
/**
 * @fileoverview Defines the core logic, schemas, and types for the tool.
 * @module
 */
import { z } from "zod";
import { logger, type RequestContext } from "../../../utils/index.js";
import { BaseErrorCode, McpError } from "../../../types-global/errors.js";

// 1. DEFINE Zod input and output schemas.
// CRITICAL: The .describe() calls are sent to the LLM and must be clear.
export const ToolInputSchema = z.object({ /* ... */ });
export const ToolResponseSchema = z.object({ /* ... */ });

// 2. INFER and export TypeScript types.
export type ToolInput = z.infer<typeof ToolInputSchema>;
export type ToolResponse = z.infer<typeof ToolResponseSchema>;

/**
 * 3. IMPLEMENT and export the core logic function.
 * It must remain pure: its only concerns are its inputs and its return value or thrown error.
 * @throws {McpError} If the logic encounters an unrecoverable issue.
 */
export async function toolLogic(params: ToolInput, context: RequestContext): Promise<ToolResponse> {
  logger.debug("Executing toolLogic...", { ...context });

  if (/* some failure condition */) {
    // CRITICAL: Logic layer MUST throw a structured error on failure.
    throw new McpError(BaseErrorCode.VALIDATION_ERROR, "A specific error message.");
  }

  // On success, RETURN a structured output object.
  return { /* ... response data ... */ };
}
```

#### **Step 2: Register the Tool and Handle Outcomes (`registration.ts`)**

The `registration.ts` file acts as the handler, connecting the logic to the server and managing all outcomes.

```typescript
/**
 * @fileoverview Handles registration and error handling for the tool.
 * @module
 */
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import {
  ErrorHandler,
  logger,
  requestContextService,
} from "../../../utils/index.js";
import {
  ToolInput,
  ToolInputSchema,
  toolLogic,
  ToolResponseSchema,
} from "./logic.js";

/**
 * Registers the tool with the MCP server instance.
 */
export const registerTool = async (server: McpServer): Promise<void> => {
  const toolName = "your_tool_name";

  server.registerTool(
    toolName,
    {
      title: "Tool Title for LLM",
      description: "Concise description of the tool's purpose for the LLM.",
      inputSchema: ToolInputSchema.shape,
      outputSchema: ToolResponseSchema.shape, // MANDATORY
    },
    async (params: ToolInput) => {
      const handlerContext = requestContextService.createRequestContext({
        toolName,
      });

      try {
        const result = await toolLogic(params, handlerContext);
        return {
          structuredContent: result,
          content: [
            { type: "text", text: `Success: ${JSON.stringify(result)}` },
          ],
        };
      } catch (error) {
        const mcpError = ErrorHandler.handleError(error, {
          operation: toolName,
          context: handlerContext,
          input: params,
        }) as McpError;

        return {
          isError: true,
          content: [{ type: "text", text: mcpError.message }],
          structuredContent: {
            code: mcpError.code,
            message: mcpError.message,
            details: mcpError.details,
          },
        };
      }
    }
  );
  logger.info(`Tool '${toolName}' registered successfully.`);
};
```

---

## III. `perplexity-mcp-server`: Core Utilities & Cheatsheet

This section provides quick references for the specific utilities and services within this project.

### 1. Error Handling (`src/types-global/errors.ts`, `src/utils/internal/errorHandler.ts`)

- **Purpose**: Standardized error objects (`McpError`) and centralized handling (`ErrorHandler`).
- **Usage**: The `registration.ts` handler for every tool **must** use `ErrorHandler.handleError` in its `catch` block. The `logic.ts` file **must** throw `McpError` for expected failures.

### 2. Request Context & Logging (`src/utils/internal/requestContext.ts`, `src/utils/internal/logger.ts`)

- **Purpose**: To track, trace, and log every operation with a unique ID.
- **Usage**: A `RequestContext` **must** be created in the `registration.ts` handler and passed through all subsequent function calls. All logging **must** be done via the `logger` singleton and include the context.

### 3. Perplexity Service (`src/services/perplexityApi.ts`)

- **Purpose**: Encapsulates all interaction with the Perplexity API.
- **Usage**: The singleton `perplexityApiService` is imported directly into the `logic.ts` file of a tool. It handles API key authentication, request formation, and basic response validation.

### 4. Cost Tracking (`src/utils/perplexity-utils/costTracker.ts`)

- **Purpose**: Estimate the cost of Perplexity API calls.
- **Usage**: After a successful API call in `perplexityApiService`, the `costTracker` is automatically invoked to log the estimated cost. This is not typically called directly from tool logic.

### 5. ID Generation & Sanitization (`src/utils/security/*`)

- **Purpose**: Provide robust security primitives.
- **`idGenerator`**: Generates unique, prefixed IDs.
- **`sanitization`**: Cleans and validates input data. `ErrorHandler` uses this automatically for logging, but it can be used for explicit sanitization in logic if needed.
- **`rateLimiter`**: Controls the frequency of operations (not yet implemented in handlers, but available).

---

## IV. Code Quality and Security Mandates

### Code Quality

- **JSDoc:** Every file shall begin with a `@fileoverview` and `@module` block. All exported functions, types, and classes shall have complete JSDoc comments.
- **LLM-Facing Descriptions:** The tool's `title`, `description`, and all parameter `.describe()` strings in Zod schemas are transmitted directly to the LLM. They must be written with the LLM as the primary audience, being descriptive, concise, and explicit about requirements.
- **Clarity and Intent:** Code shall be self-documenting. Use explicit and unambiguous names.
- **Formatting:** All code must be formatted using Prettier (`npm run format`) before commit.

### Security

- **Input Validation:** All tool input is automatically validated by the Zod schema provided during registration.
- **Secrets Management:** Hardcoding secrets is a direct violation of this standard. All secrets (e.g., `PERPLEXITY_API_KEY`) shall be loaded exclusively from environment variables via the `config` module.
